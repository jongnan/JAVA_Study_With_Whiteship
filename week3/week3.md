# 연산자(Operator)

### 📖목표

> 자바가 제공하는 다양한 연산자를 학습해보자.

### 🧮연산자란

> 프로그래밍 언어에서는 일반적인 수학에서 사용하는 연산자와 유사한 **연산자**의 집합을 지원한다.  
> 자바에서도 여러가지 연산자들을 지원하며 기존 연산(수학)보다 더욱 다양한 연산 기능도 가능하다.
> (ex - `+` 연산자를 `String` 타입에 사용시 문자열들을 연결)
>
> <p align="right">출처 : 위키백과 - 연산자(프로그래밍)</p>

<br>

## 산술 연산자

사칙 연산의 연산자들로 가장 기본적인 산술 연산에 사용된다.  
산술 외에도 다른 기능들도 존재한다.  
사칙 연산과 똑같이 **왼쪽에서 오른쪽으로 결합**하는 방식을 사용한다.

| 기호 | 설명                                                 | 에러                                      |
| :--: | :--------------------------------------------------- | ----------------------------------------- |
|  +   | 왼쪽 피연산자와 오른쪽 피연산자를 더함               |                                           |
|  -   | 왼쪽 피연산자에서 오른쪽 피연산자를 뺌               |                                           |
|  *   | 왼쪽 피연산자에 오른쪽 피연산자를 곱함               |                                           |
|  /   | 왼쪽 피연산자를 오른쪽 피연산자로 나눔               | 0으로 나눌 시 `ArithmeticException`       |
|  %   | 왼쪽 피연산자를 오른쪽 피연산자로 나눈 나머지를 반환 | 0으로 나머지 연산시 `ArithmeticException` |

기본 사칙 연산에서의 우선 순위(`*` = `/` = `%` > `+` = `-`)와 동일하게 적용되며, `()`를 사용하여 우선 순위를 정할 수 있다.

여기서 주의할 점이 존재하는데, `/`와 `%` 연산자 모두 나누기를 사용해야 하므로 부모 즉, 오른쪽 피연산자를 0일 때는 `ArithmeticException` 에러가 발생한다.

하지만, 에러가 발생하지 않고 특별한 값이 되는 경우가 존재한다.  
부동 소수점으로 표시하는 `float`과 `double` 타입을 0으로 `/` 혹은 `%`으로 연산시에 `Not a number`, `Infinity`라는 값이 된다.  
이는 "IEEE 754"에서 정의한 산술 규칙에 의해 결정된다.

* Infinity

  > 무한을 뜻하며 굉장히 큰 값을 의미한다.  
  > -Infinty도 존재하며 이는 굉장히 작은 값을 의미한다.
  >
  > 이 값은 부동 소수점 연산에 의해 Overflow가 나거나  또는 0으로 나누는 부동 소수점 연산으로 생성된다.

  ```java
  float n   =  10.0f / 0;	//  Infinity
  float n2  = -10.0f / 0;	// -Infinity
  double n3 =  10.0d / 0.0f;	//  Infinity
  ```

* NaN(Not a number)

  > 숫자가 아닌 값을 나타내며 의미없는 작업으로 생성된다.  
  > 이는 0을 0으로 나누거나, 0으로 나머지 연산시, 무한대 나누기 무한대 등의 상황에서 볼 수 있다.

  ```java
  float n  = 0.0 / 0;		//NaN
  float n2 = 10.0 % 0;		//NaN
  float n3 = 0 * (1.0 / 0);	//NaN(0 * ∞)
  float n4 = (1.0/0) / (1.0/0)	//NaN(∞ / ∞)
  ```

<br>

## 논리 연산자

논리 연산자는 주어진 식의 참과 거짓을 판단하는 역할을 한다.  
**AND와 OR 연산**은 2개의 피연산자를 가지며 **왼쪽에서 오른쪽으로 결합**한다.  
**NOT 연산** 1개의 피연산자를 가지며 **오른쪽에서 왼쪽으로 결합**한다.

| 기호 | 설명                                                         | 결합 순서     |
| :--: | ------------------------------------------------------------ | :------------ |
|  &&  | 논리식이 모두 참이면 참을 반환<br />(하나라도 거짓일시 거짓 반환) | 왼쪽 → 오른쪽 |
| \|\| | 논리식 중에 하나라도 참이면 참을 반환<br />(모두 거짓일 때만 거짓 반환) | 왼쪽 → 오른쪽 |
|  !   | 논리식의 결과가 참이면 거짓을 거짓이면 참을 반환             | 오른쪽 → 왼쪽 |

<br>

## 비트 연산자

비트 연산자는 비트 단위로 논리 연산을 할 때 사용하거나, 좌/우 쉬프트 혹은 1의 보수를 만들 때도 사용된다.

| 기호 | 설명                                                         |
| :--: | ------------------------------------------------------------ |
|  &   | 해당 위치의 비트가 모두 1이라면 1을 반환, 하나라도 0이라면 0을 반환(AND) |
|  \|  | 해당  위치의 비트가 하나라도 1이라면 1을 반환, 모두 0일시에는 0을 반환(OR) |
|  ^   | 해당 위치의 비트가 서로 다르면 1을 반환, 같으면 0을 반환(XOR) |
|  ~   | 해당 위치의 비트가 1이면 0, 0이면 1로 변환하여 반환(NOT, 1의 보수) |
|  <<  | 오른쪽 피연산자만큼 비트를 전부 왼쪽으로 이동 시킨값을 반환(새로운 비트는 0) |
|  >>  | 부호를 유지하면서 오른쪽 피연산자만큼 비트를 전부 오른쪽으로 이동 시킨값을 반환 |
| >>>  | 오른쪽 피연산자만큼 비트를 전부 오른쪽으로 이동하며 새로운 비트는 모두 0으로 한 뒤 반환 |

여기서 주의할 점은 우 쉬프트 연산이다.  
`>>`일 경우에는 부호를 유지해야 하므로 부호가 `1`일 경우, 새로운 비트들은 `1`로 채워진다.(`0`일 경우, `0`으로 채워짐)

```
[우 쉬프트]
-----------부호 비트가 0일 때-----------
00110000 >> 3
   ↓		오른쪽으로 3만큼 이동
XXX00110
   ↓		X(새로운 비트)에 0을 채움
00000110

-----------부호 비트가 1일 때-----------
11110000 >> 3
   ↓		오른쪽으로 3만큼 이동
XXX11110
   ↓		X(새로운 비트)에 1을 채움
11111110

------------------------------------
11110000 >>> 3
   ↓		오른쪽으로 3만큼 이동
XXX11110
   ↓		X(새로운 비트)에 0을 채움
00011110

====================================

[좌 쉬프트]
00001100 << 2
   ↓		왼쪽으로 2만큼 이동
001100XX
   ↓		X(새로운 비트)에 0을 채움
00110000
```

<br>

## 관계 연산자

관계 연산자는 피연산자의 크기를 판단하는 역할을 한다.  
즉, 왼쪽 피연산자와 오른쪽 피연산자 중 어떤것이 더 크고 작은지 혹은 같은지를 판별하는 것이다.  
피연산자들의 **결합 방향은 왼쪽에서 오른쪽**이다.

| 기호 | 설명                                                         |
| :--: | ------------------------------------------------------------ |
|  ==  | 왼쪽 피연산자와 오른쪽 피연산자가 같으면 참을 반환           |
|  !=  | 왼쪽 피연산자와 오른쪽 피연산자가 다르면 참을 반환           |
|  >   | 왼쪽 피연산자가 오른쪽 피연산자보다 클 때 참을 반환          |
|  >=  | 왼쪽 피연산자가 오른쪽 피연산자보다 크거나 같을 때 참을 반환 |
|  <   | 왼쪽 피연산자가 오른쪽 피연산자보다 작을때 참을 반환         |
|  <=  | 왼쪽 피연산자가 오른쪽 피연산자보다 작거나 같을때 참을 반환  |

<br>

## instanceof

`instanceof` 키워드는 해당 객체(왼쪽 피연산자)가 오른쪽 피연산자와 같은 타입(클래스/인터페이스)인지 판별한다.   
즉, `A instanceof B` 라고 할 때 `A`가 `B`에 속해있다면 `true`를 아니면 `false`를 반환한다.

```java
//Parent.java
public class Parent {
  ...
}

//Child.java
public class Child extends Parent {
  ...
}

public class main {
  public static void main(String[] args) {
    Parent p = new Parent();
    Child c = new Child();
    
    System.out.println(p instanceof Parent);	//true
    System.out.println(p instanceof Child);	//false
    System.out.println(c instanceof Child);	//true
    System.out.println(c instanceof Parent);	//true
  }
}
```

<br>

## assignment(=) 연산자

할당 연산자는 어떠한 변수 혹은 상수에 값을 대입할 때 사용하는 연산자이다.  
피연산자들의 결합 방향은 **오른쪽에서 왼쪽으로 결합**한다.  
자바에서는 할당 연산자와 다른 연산자들의 조합으로 다양한 복합 할당 연산자를 제공한다.

| 기호 | 설명                                                         |
| :--: | ------------------------------------------------------------ |
|  =   | 오른쪽 피연산자를 왼쪽 피연산자에 할당                       |
|  +=  | 왼쪽 피연산자를 오른쪽 피연산자에 더한 뒤에 그 결과값을 왼쪽 피연산자에 할당 |
|  -=  | 왼쪽 피연산자에서 오른쪽 피연산자를 뺀 뒤에 그 결과값을 왼쪽 피연산자에 할당 |
|  *=  | 왼쪽 피연산자와 오른쪽 피연산자를 곱한 뒤, 그 결과값을 왼쪽 피연산자에 할당 |
|  /=  | 왼쪽 피연산자를 오른쪽 피연산자로 나눈 뒤, 그 결과값을 왼쪽 피연산자에 할당 |
|  %=  | 왼쪽 피연산자를 오른쪽 피연산자로 나눈 뒤, 그 나머지를 왼쪽 피연산자에 할당 |
|  &=  | 왼쪽 피연산자를 오른쪽 피연산자와 AND 비트 연산 후, 그 결과값을 왼쪽 피연산자에 할당 |
| \|=  | 왼쪽 피연산자를 오른쪽 피연산자와 OR 비트 연산 후, 그 결과값을 왼쪽 피연산자에 할당 |
|  ^=  | 왼쪽 피연산자를 오른쪽 피연산자와 XOR 비트 연산 후, 그 결과 값을 왼쪽 피연산자에 할당 |
| <<=  | 왼쪽 피연산자를 오른쪽 피연산자만큼 왼쪽 쉬프트한 뒤, 그 결과값을 왼쪽 피연산자에 할당 |
| >>=  | 왼쪽 피연산자를 오른쪽 피연산자만큼 부호를 유지하며 오른쪽 쉬프트한 뒤, 그 결과값을 왼쪽 피연산자에 할당 |
| >>>= | 왼쪽 피연산자를 오른쪽 피연산자만큼 부호 상관없이 오른쪽 쉬프트한 뒤, 그 결과값을 왼쪽 피연산자에 할당 |

할당하는 값의 타입이 Reference 타입의 경우, 새로운 값을 만들어서 할당하는 것이 아닌 주소만 복사해서 할당(**얕은 복사 -  Shallow copy**)한다.  
따라서, 새롭게 할당한 값을 변환하면 기존에 할당했던 값도 변경되므로 주의해야한다.

```java
int[] arr = new int[5];
int[] arr2 = arr;
System.out.println(arr[0]);	// 0
System.out.println(arr2[0]);	// 0
arr2[0] = 5;
System.out.println(arr[0]);	// 5
System.out.println(arr2[0]);	// 5
```

이를 피하기 위해서는 **깊은 복사 - Deep copy**를 해야된다.

```java
int[] arr = new int[5];

// for문 사용
int[] arr2 = new int[arr.length];
for(int i = 0; i < arr.length; i++) {
	arr2[i] = arr[i];
}

// clone() 사용
int[] arr2 = arr.clone();

System.out.println(arr[0]);	// 0
System.out.println(arr2[0]);	// 0
arr2[0] = 5;
System.out.println(arr[0]);	// 0
System.out.println(arr2[0]);	// 5
```

위 방법 외에도 깊은 복사를 하는 방법이 존재한다.

<br>

## 화살표(->) 연산자

화살표 연산자는 Java 8에서 Lambda 표현식을 위해 나온 연산자이다.

### Lambda Expression

람다 표현식은 `(parameter list) -> {function body}`와 같이 나타낼 수 있으며 메소드의 식별자가 없기 때문에 익명(이름이 없는) 함수라고 한다.  
이러한 람다 표현식을 사용하므로써 변수에 할당할 수 있게 되었고 이로인해 함수형 프로그래밍이 가능하게 되었다.  
(기존 자바에서는 함수는 일급 객체가 아니였지만, 람다의 도입으로 인해 일급 객체로 사용이 가능해졌기 때문)

이러한 람다 표현식은 다음과 같은 규칙으로 다양하게 사용이 가능하다.

* 매개변수의 타입이 추론 가능하다면 생략 가능(여러개 중 하나만 생략은 불가능)
* 매개변수가 하나라면 `()` 가 생략 가능
* `{}` 안에 한 문장이라면 생략 가능

```java
// 기본 메서드
int add(int a, int b) {
  return a + b;
}

// 람다 표현식
(int a, int b) -> {
  return a + b;
}

// 매개변수 타입 생략
(a, b) -> {
  return a + b;
}

// 매개변수 타입 + {} + return 생략
(a, b) -> a + b;
```

이러한 람다 표현식에는 필수적인 조건 하나가 있어야 한다.  
그것은 바로 **익명 객체를 생성할 수 있는 인터페이스의 존재**이다.  
기본적으로 자바에서는 함수를 바로 변수에 할당할 수 없기 때문에 익명 객체를 통해 메소드를 오버라이딩하는 형식으로 이를 변수에 할당한다.  
따라서 람다 표현식을 사용하기 위해서는 **인터페이스가 무조건 필요**하다.

```java
// Lambda X
interface Adder {
  int excute(int a, int b);
}

class Calculator {
  public int excute(int num1, int num2, char op) {
    Adder adder = new Adder {
      @Override
      public int excute(int a, int b) {
      	return a + b;
      }
    };
    if(op == '+') {
      return adder.excute(num1, num2);
    }
  }
}

// Lambda O
interface Adder {
  int excute(int a, int b);
}

class Calculator {
  public int excute(int num1, int num2, char op) {
    Adder adder = (a, b) -> a + b;
    if(op == '+') {
      return adder.excute(num1, num2);
    }
  }
}
```

위와 같이 익명 클래스로 구현했을 때 보다 코드를 간결하게 만들 수 있다.

만약, `Adder` 인터페이스에 추상 메소드가 2개가 존재하고 있다면 어떻게 될까?  
람다 표현식은 익명 함수를 사용하기 때문에 추상 메소드가 여러개일 경우에는 식별할 수 가 없다.  
따라서, 람다 표현식을 사용하기 위해서는 1개의 추상 메소드만 존재하는 인터페이스여야만 한다.  
자바에서는 `@FunctionalInterface`라는 어노테이션을 제공하여 인터페이스가 잘 작성되었는지 확인할 수 있다.

```java
@FunctionalInterface
interface Adder {
  int excute(int a, int b);
  // int excute2(int a, int b); 작성시 에러!
}
```

여기서 인터페이스를 일일히 만들면 무엇이 편리한지 모를 수도 있다.  
그렇기에 자바에서는 자주 사용되는 형식들을 `java.util.function` 패키지로 제공하고 있다.  

```java
class Calculator {
  public int excute(int num1, int num2, char op) {
    // java.util.function 에서 제공하는 IntBinaryOperator 인터페이스
    IntBinaryOperator adder = (a, b) -> a + b;
    if(op == '+') {
      return adder.applyAsInt(num1, num2);
    }
  }
}
```

이 여러가지 형식들은 [여기](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)서 확인 할 수 있다.

<br>

## 3항 연산자

3항 연산자는 `if-else`문을 사용할 때 비효율적으로 길어지는 것을 줄이기 위해 `?`와 `:`을 사용한다.

만약, 다음과 같이 큰값을 찾는 로직이 있다고 하자.

```java
int a = 10;
int b = 5;
int max;
if(a > b) {
  max = a;
}else {
  max = b;
}
```

엄청 단순한 로직은 8줄이나 차지하게 된다.

여기서 3항 연산자를 사용하면 3줄로 줄일 수 있다.

```java
int a = 10;
int b = 5;
int max = (a > b) ? a : b;
```

`if-else`문과 할당하는 부분을 `(조건문) ? 참일 경우 : 거짓일 경우`로 줄일 수 있다.

이렇게 단순히 줄일 수 있지만, 여러개의 `if-else`문을 처리하는 복잡한 경우에 사용한다면 가독성을 해칠 뿐이다.  
따라서 위 예시와 같이 간단한 로직에서 사용하는 것이 좋다.

<br>

## 연산자 우선순위

연산자 우선순위는 밑 표에서 위가 가장 높고 아래가 가장 낮다.

|                  기호                   |             연산자              |
| :-------------------------------------: | :-----------------------------: |
|           *expr*++  *expr*--            |       증감/감소(postfix)        |
|  ++*expr* --*expr* +*expr* -*expr* ~ !  | 단항 및 증감/감소(prefix), 부정 |
|                  * / %                  |      곱셈, 나눗셈, 나머지       |
|                   + -                   |           덧셈, 뺄셈            |
|                << >> >>>                |             쉬프트              |
|          < > <= >= instanceof           |              관계               |
|                  == !=                  |           동등/비동등           |
|                    &                    |          비트 논리 곱           |
|                    ^                    |        비트 논리 합 반대        |
|                   \|                    |          비트 논리 합           |
|                   &&                    |             논리 곱             |
|                  \|\|                   |             논리 합             |
|                   ? :                   |              삼항               |
| = += -= *= /= %= &= ^= \|= <<= >>= >>>= |              할당               |

할당 연산자를 제외한 모든 이항 연산자(피연산자가 2개)는 왼쪽에서 오늘쪽으로 결합하며, 할당 연산자는 그 반대이다.

<br>

## switch 연산자

Java 12부터 새로운 switch 문이 등장했다.

```java
//기존 switch
switch(op) {
  case '+':
    result = a + b;
    break;
  case '-':
    ...
}

//새로운 switch
switch(op) {
  case '+' -> a + b;
  case '-' -> a - b;
    ...
}
```

`->` 옆에는 꼭 단일 구문만 오는것이 아니라 `{}`을 통해 수행할 코드를 작성하면 된다.  
Java 12에서는 그냥 사용할 수는 없으며 `--enable-preview` 옵션을 사용하여야만 사용할 수 있다.  
(IntelliJ IDE에서는 12(Preview)를 선택)

하지만 13부터는 이 옵션이 없어도 사용이 가능하며 `yield`라는 키워드가 생겨났다.  
`yield` 키워드는 `{}`의 안에서 반환할 값 앞에 사용한다.(12에서는 `break`)

```java
switch(op) {
    case '+' -> a + b;
    case '-' -> {
      int result = a > b ? a - b : b - a;
      yield result; // java 12 : break result;
    }
    ...
}
```

<br>

---

### Reference

* [TCP School - 연산자](http://tcpschool.com/java/java_operator_arithmetic)
* [자바/Java instanceof 연산자란?](https://arabiannight.tistory.com/313)
* [자바의 정석 - 람다식(Lambda Expression) - Integerous DevLog](https://ryan-han.com/post/java/java-lambda/)
* [Oracle doc - Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)
* [Java switch 문 - 기계인간 John Grib](https://johngrib.github.io/wiki/java-switch-expression/)
* [Java Switch Statement - baeldung](https://www.baeldung.com/java-switch)

